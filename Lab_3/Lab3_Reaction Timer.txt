.section .text
.align 2
.globl _start


// -------------------------------------------------------------------------------------
// Name:        Lab_3.S
// Purpose:     This code has 2 parts: the first part is to create a simple counter
//              subroutine that increments from 0x00 to 0xFF, wraps to 0 and continues
//              counting.  There is a 100us delay between the display of the count. 
//		The second part is a reflex meter that will measure how fast
//              a user responds to an event accurate to a 10th of a millisecond.
//              Initially, all LED's are off and after a random amount of time
//              (between 2 and 10 seconds), one LED turns on (LED_6) and then the user
//		presses pushbutton S1.  The press of the button will be monitored by
//		using "polling".
//
// Author:      Zachary Bedard and Jonathan Lyashko
// -------------------------------------------------------------------------------------


_start:

// -------------------------------------------------------------------------------------
// GPIO Control Registers Memory Mapping

    .equ GPIO_BASE_CTRL_ADDR, 0x10012000    // Base address for the GPIO control registers
    .equ GPIO_OUTPUT_EN,      0x08          // address offset for enabling GPIO outputs
    .equ GPIO_OUTPUT_VAL,     0x0C          // Address offset for writing to GPIO outputs
    .equ GPIO_OUTPUT_XOR,     0x40          // Address offset for GPIO Outputs XOR
    .equ GPIO_INPUT_VAL,      0x00          // Address offset for reading GPIO inputs
    .equ GPIO_INPUT_EN,       0x04          // address offset for enabling GPIO inputs
    .equ GPIO_PUE,            0x10          // address offset for internal GPIO pull-up resistor

// -------------------------------------------------------------------------------------
// 8 LEDS, 7 Segment LED Display Pins Register Address Mapping

    .equ GPIO_7SEGLED_PINS,   0x0000023F      // Seven Segment LED Display Pins (7)
    .equ GPIO_LEDBAR_PINS,    0x00FC0C00      // LED Bar Pins (8)
    .equ GPIO_ALL_LED_PINS,   0x00FC0E3F      // All LED Pins (15)
    .equ GPIO_LEDBAR_LED_1,   0x00000800      // LEDBAR LED1

// -------------------------------------------------------------------------------------
// Pushbuttons SW(x) Register Address Mapping

    .equ GPIO_SW_1,           0x00001000      // SW1 pushbutton (bit 12)
    .equ GPIO_SW_2,           0x00002000      // SW2 Pushbutton (bit 13)
    .equ GPIO_ALL_PBS,        0x00003000      // All Pushbutton Pins (bits 12, 13)

// Initialize the GPIO control registers
// -------------------------------------------------------------------------------------

    li t0, GPIO_BASE_CTRL_ADDR          // Load Base Address for GPIO Control Registers
    li t1, GPIO_ALL_LED_PINS            // Load GPIO Register to set GPIO_OUTPUT_EN and GPIO_OUTPUT_XOR registers for all GPIO LED Pins
    sw t1, GPIO_OUTPUT_EN(t0)           // Enable outputs on all GPIO LED Pins
    li t2, 0xFF03F1C0
    sw t2, GPIO_OUTPUT_VAL(t0)          // Set all LED pins to zero to turn off all LEDS.
    li t1, GPIO_SW_1                    // Load GPIO Register to set GPIO_INPUT_EN for input pins
    sw t1, GPIO_INPUT_EN(t0)            // Enable inputs on all Pushbutton pins

// -------------------------------------------------------------------------------------


INITIAL:

// Initialize random number generator
 	li a7, 0xABCD                   // Initializes register a7 to a 16-bit non-zero value and NOTHING else can write to a7 !!!!
    //j COUNTER

/*
COUNTER:
        li s0, 0xff
    start:
        li t2, 0x00
    loopCount:
        li s0, 0x000c3500   // Load 0.1s () value
        addi t2, t2, 1      // Increment initial counter
        andi a1, t2, 0x3    // Mask to leave last two bits (Need these in 10 and 11)
        andi a2, t2, 0xFC   // Mask to leave first 6 digits in number (Need these in 18 to 23)
        slli a1, a1, 10     // Store first 2 LED bits in a1 after isolating
        slli a2, a2, 16     // Store last 6 LED bits in a2 after isolating
        add a3, a1, a2      // Put the values together to create the output signal
        sw a3, GPIO_OUTPUT_VAL(t0)
        beq t2, s0, start   // Once we get to 0xFF in t2 start again at 0
    loopTime:
        addi s0, s0, -1     // Decrement
        bnez s0, loopTime      // Branch after 0.1s
        j loopCount              // Jump back to the loop to see if we need to decrement again
*/

// -------------------------------------------------------------------------------------

start:
loop:
    li t5, 0x0
    sw t5, GPIO_OUTPUT_VAL(t0)     //Turn off all LEDs

    jal ra, RandomNum           //Generate random number

    li t1, 0xFFFF               //Filter out so only the last 16-bits remain
    li t4, 0x4E20               //Base when zero is generated (lower bound of 2s)
    and a7, a7, t1              //Save random value generated from the random subroutine after it's been masked

    li t1, 80000                //New max range
    li t2, 65535                //Old max range
    mul t3, a7, t1              //Scale number up to max range
    div t3, t3, t2              //Reduce so it's within the appropriate range
    add a1, t3, t4              //Random number plus 20000 is how many times the delay loop should run

    //mv a1, t2
    //addi a1, t2, 0
    jal DELAY

//  Once your number has been generated, it will be stored in register a7. Do not overwrite this!
//  You will now need to set up delays, timer, subroutines to turn the LED ON and OFF, and for polling whether the Pushbutton S1 has been pressed.
//  Keep in mind that you will get a 32-bit number back from the timer that measures the time between the LED turning ON and the press of the pushbutton.
//  You will need to display this 8 bits at a time, starting with the lowest 8 bits.


//   --------------- Place your code here ----------------------------------------



DISPLAY:    //a0 has argument number (Reflex number)

// Display the 32-bit number on the 8-LED Bar

// Register t1 holds the value of the number to be displayed
// Map each bit of the number to the corresponding LED Bar bit
// MSB to LSB: bits 23, 22, 21, 20, 19, 18, 11, 10
//

    li t5, 0xff         //Mask for the first byte
    and a3, a0, t5      //Number to send to DISPLAY_NUM
    jal DISPLAY_NUM

    li t5, 0xff00       //Mask for the second byte
    and a3, a0, t5      //2nd byte to DISPLAY_NUM
    srli a3, a3, 8      //Shift bits so it's in the desired form for DISPLAY
    jal DISPLAY_NUM

    li t5, 0xff0000     //Mask for the third byte
    and a3, a0, t5      //3rd byte to DISPLAY_NUM
    srli a3, a3, 16     //Shift bits so it's in the desired form for DISPLAY
    jal DISPLAY_NUM

    li t5, 0xff000000   //Mask for the forth byte
    and a3, a0, t5      //4th byte to DISPLAY_NUM
    srli a3, a3, 24     //Shift bits so it's in the desired form for DISPLAY
    jal DISPLAY_NUM

    li t5, 0x2625A00    //Load the number of instructions in 5 seconds (16M/2 * 5)
    Delay5s:            //Delay for 5 second before starting the display again
        addi t5, t5, -1
        bnez t5, Delay5s
        j DISPLAY

DISPLAY_NUM: //Arguement register is a3
      addi sp, sp, -16
      sw ra, 12(sp)
    
    loopCount:
        li s0, 0x00F42400   // Load 2s value
        andi a1, a3, 0x3    // Mask to leave last two bits (Need these in 10 and 11)
        andi a2, a3, 0xFC   // Mask to leave first 6 digits in number (Need these in 18 to 23)
        slli a1, a1, 10     // Store first 2 LED bits in a1 after isolating
        slli a2, a2, 16     // Store last 6 LED bits in a2 after isolating
        add a3, a1, a2      // Put the values together to create the output signal
        sw a3, GPIO_OUTPUT_VAL(t0)
        beq t2, s0, start   // Once we get to 0xFF in t2 start again at 0
    loopTime:
        addi s0, s0, -1     // Decrement
        bnez s0, loopTime   // Branch after 2s
        
// Remember, the 8 LEDS are mapped to the GPIO as bits MSB to LSB: bits 23, 22, 21, 20, 19, 18, 11, 10      

      lw ra, 12(sp)
      addi sp, sp, 16
      ret

// Random Number generator
// Register a7 holds the random number.
// You can read this value anywhere in the code, but this register can only be written to by this subroutine
// Or Else!

RandomNum:
     addi sp, sp, -16
     sw ra, 12(sp)


     li s4, 0x8000		     // Load upper 20 bits
     and t1, a7, s4  		     // Mask to lower 16 bits
     li s4, 0x2000  		     // Load upper 20 bits
     and t3, a7, s4  		     // Mask to lower 16 bits


     slli t3, t3, 2
     xor t3, t1, t3
     li s4, 0x1000  		     // Load upper 20 bits
     and t1, a7, s4		     // Mask to lower 16 bits

     slli t1, t1, 3
     xor t3, t3, t1
     andi t1, a7, 0x0400
     slli t1, t1, 5
     xor t3, t3, t1
     srli t3, t3, 15
     slli a7, a7, 1
     or a7, a7, t3		     // Register a7 holds the random number

     lw ra, 12(sp)
     addi sp, sp, 16
     ret

DELAY:
     addi sp, sp, -16
     sw ra, 12(sp)
	
         //addi a1, a1, 1      // a1 has iterations, add 1 to it so it loops properly (starting at 5 going down to 1 has a difference of 4, our loop is based off the difference)
     loopCounter:
         li t1, 0x320        // Load 0.1ms value 
     loopTimer:
         addi t1, t1, -1     // Decrement
         bnez t1, loopTimer      // Branch back and start again if 0.1ms hasn't passed
         addi a1, a1, -1     // Decrement the counter (number of multiples of 0.1ms we want)
         bnez a1, loopCounter

    li t4, 0x00400000           //Turn on light after the loop has gone through
    sw t4, GPIO_OUTPUT_VAL(t0)

     li t1, 0x0 //Initialize counter for reaction time
     Reflex:
        lw t2, GPIO_INPUT_VAL(t0) //Take in value from the switch
        li t3, GPIO_SW_1          //Load mask of button into a register to be used
        and t2, t2, t3            //Mask off all values that are undesired (Anything other than bit 12)
        beqz t2, Reacted          //If the value of the button is 0 (Active low) the button has been pressed and continue to displaying the value

        li t4, 0x320              //Load value of 0.1ms in terms of instructions into another counter
        ReflexCount:
            addi t4, t4, -1       //Decrement until 0.1ms has passed
            bnez t4, ReflexCount
            addi t1, t1, 1        //Only gets here once 0.1ms has passed. Increment reaction time
            bnez t2, Reflex       //if the button isn't pressed (Input_Val != 0 from active low) start the whole loop again to check the status of the button

    Reacted: 
        li t4, 0x0                      
        sw t4, GPIO_OUTPUT_VAL(t0) //Turn off the LED
        mv a0, t1                  //Move the Reaction time count into an arguement register to be displayed

     lw ra, 12(sp)
     addi sp, sp, 16
     ret


//Questions:
//Question 1:
//If a 32-bit register is counting user reaction time in 0.1 milliseconds increments, what is the maximum amount of time which can be stored in 8 bits, 16-bits, 24-bits and 32-bits?

//The max time to be stored is the max value found in the each type of register (2^n-1 where n is the register size) multiplied by 0.1ms
//8-bits: 2^8-1 = 255 * 0.1ms = 25.5ms or 0.0255s
//16-bits: 2^16-1 = 65535 * 0.1ms = 6553.5ms or 6.5535s
//24-bits: 2^24-1 = 16777215 * 0.1ms = 1677721.5ms or 1677.7215s or 27.962025 minutes
//32-bits: 2^32-1 = 4294967295 * 0.1ms = 429496729.5ms or 429496.7295s or 7158.278825 minutes or 119.304647 hours or 4.9718603 days

//Question 2:
//Considering typical human reaction time, which size would be the best for this task (8, 16, 24, or 32 bits)?

//The best size for this task would be 16-bits. From our testing the normal human reaction time is around 250ms or 0.25s. The 8-bit register would be much too small to get an accurate reading of the reaction time. 24-bit, and by extension any register bigger that 24-bits would be excessive as a human will react to a light much faster than 27 minutes. 16-bits is the best size for this task as it can store up to 6.5535s which is more than enough time to get an accurate reading of a human reaction time while also being small enough that it doesn't waste memory.

//Question 3:
//Prove time delay meets 2 to 10 sec +/- 5% spec. 

//The way that we designed our time delay involved changeing the range to be the approriate number then scaling the range to the appropriate max and min values. First we start with the fact that the random number generator creates a number within the range of 0 and 65535 due to it creating 16-bit numbers. Once that random number is created we scale the number up to fit in the range of 0 to 80000. The way that we do this is by multiplying the number by 80000, creating a temporary range of 65535*80000. This means that the number created by the number generator is proportionally in the same spot in that bigger range. After that we divide the number by 65535 to reduce the range back down to 80000. Once we've done this our current range is 0 to 80000. to get it up to the range of 20000 to 100000 we add 20000 to the number. This number that has been created is the number of 0.1ms delays we need. 